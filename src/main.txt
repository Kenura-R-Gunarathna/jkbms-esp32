#include <Arduino.h>
#include <HardwareSerial.h>
#include <FS.h>
#include <SPIFFS.h>
#include <Arduino_JSON.h>

#define RX 16 // GPIO pin used for receiving data from JKBMS (JKBMS.TX --> ESP32.GPIO:RX)
#define TX 17 // GPIO pin used for transmitting data to the JKBMS device (JKBMS.RX --> ESP32.GPIO:TX)

HardwareSerial BMS_SERIAL(2); // Use Serial2 for UART2

#define BMS_BAUD_RATE 115200 // Adjust to your BMS's baud rate
#define DEBUG true

#define MAX_DATA_LENGTH 200 // Increased for safety (adjust based on your frame size)

byte data[MAX_DATA_LENGTH]; // Array to store received data
int dataIndex = 0;         // Index to track current position in the array
bool frameReceived = false;  // Flag to indicate a complete frame has been received

// JSON Configuration
JSONVar config;
int dataFrameLength;

// Function Prototypes
void readBMSData();
void decodeBMSData(const byte* data);
void printDecodedData(const byte* data);
bool loadConfig(const char* filename);
int findDataFieldIndex(const JSONVar& dataFields, byte code);

void setup() {
  Serial.begin(115200); // Initialize Serial Monitor for debugging
  BMS_SERIAL.begin(BMS_BAUD_RATE, SERIAL_8N1, RX, TX); // Initialize Serial1 for BMS communication (RX pin, TX pin)

  Serial.println("ESP32 JKBMS Decoder Starting...");

  // Initialize SPIFFS
  if (!SPIFFS.begin(true)) {
    Serial.println("An Error has occurred while mounting SPIFFS");
    while (true)
      ;
  }

  // Load JSON configuration
  if (!loadConfig("/jkbms_protocol.json")) {
    Serial.println("Failed to load configuration. Halting.");
    while (true)
      ;
  }
}

void loop() {
  readBMSData(); // Read data from the BMS

  if (frameReceived) {
    decodeBMSData(data); // Decode the data
    frameReceived = false;  // Reset the flag
  }
}

// Function to read data from the BMS serial port
void readBMSData() {
  while (BMS_SERIAL.available() > 0) {
    byte inByte = BMS_SERIAL.read();

    if (dataIndex == 0 && inByte != strtol(((const char*)config["header"]["start_bytes"][0]), NULL, 16)) {
      // Wait for the start byte
      if (DEBUG) Serial.print("Skipping byte: 0x");
      if (DEBUG) Serial.println(inByte, HEX);
      continue;
    }

    data[dataIndex++] = inByte;

    if (dataIndex >= MAX_DATA_LENGTH) {
      frameReceived = true;
      dataIndex = 0; // Reset the index for the next frame
      break;           // Exit the loop after receiving a complete frame
    }
  }
}

void decodeBMSData(const byte* data) {
  // Check header
  if (data[0] != strtol(((const char*)config["header"]["start_bytes"][0]), NULL, 16) || data[1] != strtol(((const char*)config["header"]["start_bytes"][1]), NULL, 16)) {
    Serial.println("Invalid Header!");
    return;
  }

  printDecodedData(data);
}

// Helper function to convert bytes to a number (int or float)
template <typename T>
T bytesToNumber(const byte* data, int index, int length, float scale = 1.0) {
  T result = 0;
  for (int i = 0; i < length; ++i) {
    result <<= 8;
    result |= data[index + i];
  }
  return (T)(result * scale);
}

// Specialization for float
template <>
float bytesToNumber<float>(const byte* data, int index, int length, float scale) {
  unsigned long result = 0;
  for (int i = 0; i < length; ++i) {
    result <<= 8;
    result |= data[index + i];
  }
  return static_cast<float>(result) * scale;
}

// Function to decode and print BMS data in a tabular format
void printDecodedData(const byte* data) {
  Serial.println("------------------------------------------------");
  Serial.println("JKBMS Data:");
  Serial.println("------------------------------------------------");

  JSONVar dataFields = config["data_fields"];

  for (int i = 0; i < dataFields.length(); ++i) {
    JSONVar fieldConfig = dataFields[i];

    String fieldName = (const char*)fieldConfig["name"];

    long code = strtol(((const char*)fieldConfig["code"]), NULL, 16);

    if (code == 0x79) { // Cell Voltages
      Serial.println("--- Cell Voltages ---");
      int cellcountByteIndex = (int)fieldConfig["cellcount_byte_index"];
      int cellCountMultiplier = (int)fieldConfig["cell_count_multiplier"];

      byte cellVoltageByteCount = data[cellcountByteIndex]; // Number of bytes of cell voltages
      int numCells = cellVoltageByteCount / cellCountMultiplier;
      int cellIndexBase = (int)fieldConfig["cell"]["cell_index_base"]; // Where the cell info begins

      for (int j = 0; j < numCells; j++) {
        int cellNumber = data[cellIndexBase + j * cellCountMultiplier];
        int voltageIndex = cellIndexBase + j * cellCountMultiplier + 1;

        float scale = strtof((const char*)fieldConfig["cell"]["scale"], NULL);
        int length = (int)fieldConfig["cell"]["data_length"];
        int voltage = bytesToNumber<int>(data, voltageIndex, length);

        Serial.print("Cell ");
        Serial.print(cellNumber);
        Serial.print(" Voltage: ");
        Serial.print(voltage * scale); // Convert mV to V
        Serial.println(" V");
      }
    } else { // all other data points
      // Generic data processing based on JSON configuration
      int index = (int)fieldConfig["index"];
      int length = (int)fieldConfig["data_length"];
      String label = (const char*)fieldConfig["label"];  // Use label instead of name for display
      String unit = (const char*)fieldConfig["unit"];
      String type = (const char*)fieldConfig["type"];
      float scale = static_cast<float>(strtod(((const char*)fieldConfig["scale"]), NULL));

      Serial.print(label); // Use the label for printing
      Serial.print(": ");

      if (type.equals("int")) {
        int value = bytesToNumber<int>(data, index, length, scale);
        Serial.print(value);
      } else if (type.equals("float")) {
        float value = bytesToNumber<float>(data, index, length, scale);
          if (fieldConfig.hasOwnProperty("signed") && (bool)fieldConfig["signed"]) {
            // Check the most significant bit and adjust the value accordingly
            if ((data[index] & 0x80) == 0x80) {
              value = (bytesToNumber<unsigned int>(data, index, length) - 65536) * scale;
            }
          }
        Serial.print(value);
      } else if (type.equals("long")) {
        long value = bytesToNumber<long>(data, index, length, scale);
        Serial.print(value);
      } else if (type.equals("string")) {
        char value[length + 1];
        for (int k = 0; k < length; k++) {
          value[k] = (char)data[index + k];
        }
        value[length] = '\0';
        Serial.print(value);
      }

      if (unit.length() > 0) {
        Serial.print(" ");
        Serial.print(unit);
      }
      Serial.println();
    }
    Serial.println();
  }

  Serial.println("------------------------------------------------");
  Serial.println();
}

// Function to load the JSON configuration file from SPIFFS
bool loadConfig(const char* filename) {
  File file = SPIFFS.open(filename);
  if (!file || file.isDirectory()) {
    Serial.println("- failed to open file for reading");
    return false;
  }

  Serial.println("- Reading config file:");
  String fileContent;
  while (file.available()) {
    fileContent = file.readString();
    Serial.print(fileContent);
  }
  Serial.println();

  // Parse JSON data from the file content
  config = JSON.parse(fileContent);

  if (JSON.typeof(config) == "undefined") {
    Serial.println("Parsing input using JSON.parse failed!");
    file.close();
    return false;
  }

  file.close();
  return true;
}